Hidden Binary Search Tree, a New Concept of Binary Tree

O trabalho propõe um novo modelo de Árvore Binária e Árvore Binária de Pesquisa, ambas pseudo-balanceadas. As estruturas são ditas pseudo-balanceadas pois embora não sejam completamente balanceadas como a Árvore AVL por exemplo, elas possuem um limite de desbalanceamento não sendo superior ao teto do log do intervalo dos possíveis valores chaves, e uma de suas propriedades mais interessantes é que não usamos rotação para isso.
A Árvore Oculta (assim chamada), foi idealizada pelo professor Saulo Jorge Beltrão de Queiroz e traz um novo modelo de inserção dos elementos em uma árvore binária. Em seu artigo "Hidden Binary Search Tree" é citado a forma base de seu funcionamento através do número oculto. O número oculto representa o limite inferior e superior do nó mais a média entre eles e estes valores são constantes para cada vértice e não ficam gravados nos nós, por isso é que são chamados de número oculto.
Uma propriedade desta estrutura é que cada nó possui intervalo único e fixo. Isso implica que não podemos excluir um nó do meio, apenas nós folhas, ou estaremos quebrando sua principal propriedade que é a da divisão dos elementos, onde dividimos metade dos possíveis valores chaves para a esquerda do nó pai e a outra metade para a direita, e é esta propriedade que garante encontrarmos qualquer elemento na árvore e estipularmos a altura máxima da árvore dada por teto do log da diferença entre limite superior e inferior, que também representa a complexidade do algoritmo.
Os limites inferior e superior também podem ser dinâmicos e podem crescer conforme a necessidade. Podemos ter apenas um dos limites dinâmicos ou os dois ao mesmo tempo. Além disso, temos três variações de inserção dinâmica. Dinamic Memory que gasta mais memória do que o necessário porém traz uma ideia mais simples de uso e implementação. Dinamic Jump onde deixamos brexas para que novos nós sejam inseridos entre dois nós. Dinamic Step onde os limites crescem passo a passo podendo os valores chaves não estarem dentro de seu respectivo intervalo porém em ordem de pesquisa. Este último modelo funciona apenas para a estrutura Árvore Binária de Pesquisa Oculta.
A Árvore Oculta funciona muito bem para números inteiros (char, short, int e long long) que possuem intervalos bem definidos. Os tipos float e double possuem intervalos muito grandes e isso pode deixar a árvore pesada em um dos ramos dependendo das chaves a serem inseridas, porém se a distribuição das chaves for uniforme, esta estrutura funcionará perfeitamente.  O tipo string não possui bom desempenho nesta estrutura, pois além de seu limite superior tender ao infinito , uma função para encontrar a média de duas strings é custosa e tornará esta estrutura igual ou mais lenta do que as principais concorrentes (Árvore AVL e Árvore Rubro-Negra).
Em testes preliminares, já observamos que seu desempenho é superior a Árvore AVL e a Árvore Rubro-Negra em aproximadamente 10% (quando trabalhado com números de intervalo de até 2 elevado a 32, ou seja, tipo int). Além disso, esta estrutura usa menos memória e é mais simples de entender e implementar.

HIDDEN TREE
A Árvore Oculta funciona dentro de um intervalo previamente definido. Dado o intervalo dos valores chaves, calculamos a média deste intervalo. Seja INÍCIO a representação do limite inferior e FIM a representação do limite superior das chaves a serem inseridas, então a MÉDIA será dada por: MÉDIA = (INÍCIO + FIM) / 2. Este valor médio será a nossa base para sabermos se devemos ir para a esquerda ou para a direita da árvore, logo não olharemos para o valor da chave para determinar a direção, mas sim para a variável MÉDIA.
Sempre que formos inserir um elemento na árvore Oculta, devemos calcular a variável MÉDIA. Se a árvore está vazia, apenas criamos o nó cabeça. Se tiver algum elemento, verificamos se a chave a ser inserida é menor que o valor da MÉDIA, se sim olharemos para o ponteiro da esquerda do nó e atualizamos a variável FIM, senão se a chave a ser inserida for maior que a variável MÉDIA olharemos para o ponteiro da direita do nó e atualizamos a variável INÍCIO. Iterativamente, as variáveis INICIO, FIM e MÉDIA são atualizadas conforme vão descendo na árvore, se for para a esquerda: FIM = MÉDIA, se for para a direita: INICIO = MÉDIA, em ambos os casos a variável MÉDIA é recalculada na próxima iteração, exatamente como na Busca Binária ou no Merge Sort.
Quando a chave e a MÉDIA forem iguais, devemos trocar os valores da chave que está sendo inserida com a chave do nó que estamos e iteragir novamente com a mesma variável MÉDIA. Esta troca garantirá que a chave inserida fique em seu devido lugar e a árvore fique melhor balanceada, com altura máxima bem definida, e quando a árvore estiver completa, com todos os elementos do seu intervalo, ela estará perfeitamente balanceada e em ordem (mesmo a Árvore Binária Oculta), como uma árvore de pesquisa binária.
Esta estrutura não necessita rotacionamento, pois ela é auto balanceada por seu intervalo. Quando calculamos a MÉDIA jogamos metade dos possíveis valores para a esquerda e a outra metade para a direita. Pode acontecer de serem inseridos elementos apenas em um dos lados da árvore, porém este desbalanceamento terá uma altura máxima de teto(log(FIM - INÍCIO)), exemplificadamente falando de valores do tipo long long teremos um desbalanceamento máximo de 64 de altura, se tivermos elementos inseridos em apenas um dos lados da árvore e nada no outro, o que pode ser considerado uma constante pequena para um processador atual.
Logo, as buscas nesta árvore serão dadas pela comparação com a variável MÉDIA do nó. Assim conseguimos encontrar qualquer elemento na árvore ou concluir que aquela chave não está inserida. Como o intervalo é dividido ao meio a cada iteração, temos que a altura máxima da Árvore Oculta é dado por teto(log(FIM - INICIO)), logo temos que as operações de inserção, busca e remoção serão logarítmicas. Outro detalhe é que não precisamos passar quaisquer informações dos nós filhos para os nós pais, exceto do endereço de uma nova inserção ou exclusão, portanto não necessitamos utilizar recursividade nas funções, nem ter variáveis apontando para o pai.
Vale notar que poderíamos atualizar INÍCIO e FIM de forma diferente, por exemplo se formos para a esquerda poderíamos diminuir em 1 a variável FIM sendo agora: FIM = MÉDIA – 1, e não alteraríamos a complexidade da árvore nem sua estrutura e ela continuaria funcionando, porém os elementos ficariam arranjados em uma outra ordem pois o valor da MÉDIA da próxima iteração poderia ser diferente. No capítulo X falaremos mais sobre as implicações de cada atualização e porque este foi o modelo escolhido.
Graficamente usaremos colchetes com valores dentro deles ao lado de cada nó para identificar seu número oculto, representado pelo limite inferior, a média e o limite superior respectivamente, separados por vírgula. Por definição, o limite inferior e o limite superior de cada nó não estarão inclusos nos seus possíveis valores chaves para o modelo de atualização escolhido, porém usaremos colchetes fechados para representar o número Oculto (limite inferior, média, limite superior).
A Árvore Binária Oculta possui uma propriedade particular o qual um nó pode possuir qualquer um dos valores do seu intervalo independente do valor dos outros nós. Isso implica que um filho da esquerda pode ter valor chave maior de que seu pai, ou um filho da direita pode ter valor chave menor de que seu pai. Esta propriedade permite aplicarmos uma variação da forma de remoção de um nó na árvore, ao invés de realmente removermos o elemento podemos apenas indicar que o elemento foi removido e na próxima inserção poderemos usar este nó para a nova inserção sem precisarmos necessariamente aplicar desalocação e alocação de memória novamente, o que em algumas situações pode ser algo custoso computacionalmente.

TRAVESSIA
A operação de travessia será um pouco mais custosa, pois os elementos não estão totalmente ordenados. Para realizá-la precisamos encontrar o menor valor da árvore e o próximo menor consecutivamente. 
Pelas definições, sabemos que o valor do nó pai pode ser qualquer valor dentro do seu intervalo: ele pode ser menor que o menor valor dentre seus filhos a esquerda e pode ser maior que o maior valor dentre seus filhos a direita, logo não podemos dizer nada a respeito do nó pai. Porém, sabemos que todos seus filhos a esquerda são menores que qualquer filho a sua direita. Logo nossa única dúvida será com relação ao pai de cada nó.
Portanto, para encontrar o menor elemento precisamos encontrar o elemento folha mais a esquerda da árvore, comparar seu valor com todos os seus encestrais e então poderemos dizer qual o menor valor da árvore. Iterativamente buscaremos o nó folha mais a esquerda que ainda não foi dito menor e comparando ele com seus ancestrais que ainda não foram ditos menores, e assim teremos nossa travesia completa. Note que se um elemento não folha possuir todos os seus filhos como atravessados e ele próprio ainda não, então definimos nesta ocasião que este nó é folha.
Com isso temos que o tempo da travessia é O(n * altura(n)), como a altura máxima da árvore é teto(log(FIM - INÍCIO)), temos que o tempo de travessia é O(n * (teto(log(FIM - INíCIO)) ). 
Note que para cada nó analizamos todos os seus ancestrais e muitos nós possuem ancestrais comuns, assim podemos utilizar princípios da programação dinâmica para otimizar nossa travessia. Passando por todos elementos com uma busca em profundidade da esquerda para a direita e utilizando uma fila de prioridades para determinar o menor elemento de um ramo, sempre que estivermos descendo na árvore inserimos o elemento na fila, afinal enquanto não chegarmos na folha não poderemos dizer quem é o menor elemento, e sempre que estivermos subindo na árvore excluímos um elemento da fila, pois todos os possíveis candidatos a menor elemento já estão nesta fila, assim atravessaremos a árvore em tempo O(n * 2 * log(altura(n)), pois a fila de prioridades terá um máximo de elementos igual a altura máxima da árvore e cada elemento executará duas operações na fila de prioridades, de inserção e de remoção, o qual são operações logarítmicas relativas à quantidade de elementos inseridos na fila.
Quando estivermos em um nó folha e formos voltar da recursão, retiramos um elemento da fila de prioridades, se o elemento removido for menor ou igual que o valor do nó atual podemos continuar retirando elementos da fila até que a condição seja desfeita ou que a fila esteja vazia, pois obedecendo a busca em profundidade da esquerda para a direita, sabemos que se existir mais elementos a serem percorridos e consequentemente inseridos na fila, estes elementos estarão a direita do nó atual, o que significa que são valores maiores que o nó atual, portanto podemos retirar da fila de prioridades todos os elementos menores que o valor do nó atual mais o nó atual, se ele ainda estiver lá.

REMOÇÃO
Para remover um elemento basta chegar até ele, se for folha removemos e atualizamos o ponteiro do pai, senão devemos aplicar a substituição mesmo que o elemento possua um único filho, pois nesta estrutura cada vértice possui um valor oculto único e insubstituível, caso ligássemos o pai ao filho único do vértice a ser removido estaríamos alterando o valor oculto do filho e isso poderia causar quebra da propriedade do meio, onde os filhos da esquerda devem ser menores que a MÉDIA e os filhos da direita devem ser maiores que a MÉDIA do nó pai.
A substituição é a mesma utilizada com outras estruturas como a AVL, onde procuramos pelo menor elemento da direita para substituir o vértice que será removido, ou pelo maior elemento da esquerda caso seja um vértice de filho único o qual este filho seja da esquerda.
Como sabemos, esta estrutura permite que o nó pai seja qualquer valor dentro do seu limite o que não a torna de pesquisa. Esta propriedade permite que aplicamos uma variação da remoção exclusiva para esta estrutura. Quando formos remover um nó de meio, ao invés de aplicar a substituição apenas alteramos o valor da chave daquele nó por outro valor que indique que aquele vértice foi removido, por exemplo -1 se os negativos não fizerem parte do intervalo do nó raiz, dessa forma mantemos alocado o nó removido. Se em algum momento todos os filhos de um nó removido também estiverem removidos, então desalocamos este nó.
Se no processo de inserir um  elemento novo encontrarmos um campo com sinal de remoção(-1), podemos adicionar este elemento novo ali mesmo, pois o nó pai pode ser qualquer elemento do intervalo e se chegamos até aquele nó significa que aquela chave pertence aquele intervalo, porém antes de efetivamente adicionarmos a chave à este vértice devemos fazer uma busca até a folha para certificar-se de que aquele elemento já não está inserido nos vértices abaixo.
Este método de exclusão só será útil e eficiente para distribuições uniformes permitindo que um nó excluído de forma preguiçosa possa ser rapidamente preenchido por outro pertencente ao mesmo intervalo, o que poderia não ocorrer se a distribuição não fosse uniforme. E o número de inclusões seja maior que o número de exclusões, não desperdiçando memória e ganhando em desempenho pois não será aplicado desalocação e alocação novamente o qual são funções custosas para o sistema.

INSERÇÃO COM PROPAGAÇÃO
Dado a estrutura original da Árvore Oculta, faremos uma pequena modificação na função de inserção. A cada iteração, antes de irmos para a direita ou para a esquerda, verificamos se o nó atual for maior ou menor que a nova chave a ser inserida, e dependendo disso, faremos uma troca de valores entre a chave atual e a nova chave. Caso a nova chave seja menor que a variável MÉDIA devemos ir para a esquerda, nesse caso verificamos se a chave atual é menor que o valor da nova chave, se sim trocamos os valores, dessa forma, garantimos que os filhos da esquerda sempre serão menores que o pai. Caso a nova chave seja maior que a variável MÉDIA devemos ir para a direita, nesse caso verificamos se a chave atual é maior que a nova chave, se sim trocamos os valores, dessa forma, garantimos que os filhos da direita sempre serão maiores do que o pai. Com esta pequena modificação, transformamos a Árvore Oculta em uma Árvore de Pesquisa Binária.
   

INTERVALO FIXO
Até agora o limite superior podia ser dado pelo usuário como sendo qualquer número (sendo a chave um inteiro positivo), e sabemos que a altura da árvore se deve unicamente em função do teto(log(FIM – INICIO) ), ou seja, a altura cresce em função das potências de 2, logo se definirmos um intervalo com 20 elementos e um intervalo com 30 elementos, ambos terão a mesma altura máxima, dada por log(32) = 5, que é a menor potência de 2 maior que o intervalo dado. Sendo assim, podemos definir nossos intervalos sempre em função das potências de 2.
Por praticidade, definiremos nosso limite inferior como sendo 0 e nosso limite superior como sendo a menor potência de 2 maior que o intervalo dado pelo usuário. Note que a divisão para encontrar o valor da variável MÉDIA para intervalos de potência de 2, sempre será uma divisão inteira, se e somente se, o cálculo para atualizar as variáveis limites for dado por atribuição direta da variável MÉDIA, no caso se descermos para a esquerda FIM = MÉDIA, se descermos para a direita INÍCIO = MÉDIA, dessa forma garantimos divisões inteiras. Note também que os limites de cada nó nunca entrarão na sua sub árvore, pois o limite já foi inserido no nó pai, logo podemos definir o intervalo de 0 a 16 como sendo [0,8,16].
 
A cada nível que desce o intervalo diminui exatamente pela metade, assim podemos definir uma variável chamada JUMP que será o valor do salto para o próximo nível, então quando quisermos atualizar MÉDIA simplesmente diminuímos JUMP ou adicionamos JUMP a variável MÉDIA, dependendo se for para a esquerda ou para a direita respectivamente, em seguida atualizamos JUMP dividindo por 2. Estes pequenos ajustes tornam o cálculo do MÉDIA mais rápido ganhando em desempenho.
Em situações que nosso limite inferior é diferente de zero, basta calcularmos a diferença entre o limite superior e o limite inferior, ao resultado encontramos a menor potência de 2 maior do que ele, subtraimos essa potência de 2 encontrada ao resultado anterior e esse novo resultado adicionamos ao limite superior, dessa forma nossos cálculos de JUMP funcionarão perfeitamente para este novo intervalo sem alterar a altura máxima da árvore, e nossa variável JUMP inicia com a metade do valor da potência de 2 encontrada. 
Exemplo: Seja -3 o limite inferior e 9 o limite superior, a diferença entre 9 e -3 é igual a 12, menor potência de 2 maior que 12 é 16, diferença entre 16 e 12 igual a 4, adicionamos 4 ao limite superior que era 9 ficando agora igual a 13, temos então limite inferior -3, limite superior 13 e JUMP igual a 8 que é a metade de 16. A altura máxima da árvore permanecerá 4 e podemos agora calcular a MÉDIA com o JUMP. 
Também é possível diminuir o limite inferior ao invés de aumentar o limite superior, nesse caso diminuindo na mesma proporção que seria aumentado, ou ainda, podemos intercalar aumentando um pouco o limite superior e diminuindo o restante do limite inferior, o importante é que a diferença entre limite inferior e limite superior seja igual a uma potência de 2 para que o cálculo de JUMP funcione.

INSERÇÃO DINÂMICA
Um dos problemas ainda restante é o tamanho fixo do intervalo. Relembremos de que cada nó possui um número oculto único e constante, caso contrário quebraríamos as propriedades da árvore. Logo, o segredo não é mexer na estrutura ou criar novos filhos, mas sim criar novos pais como sendo raiz da árvore. Quando adicionamos um novo nó raiz aumentamos a altura da árvore em 1 e dobramos o seu intervalo, caso conectemos o antigo nó raiz a esquerda de um novo nó raiz aumentaremos o dobro do limite superior, caso conectemos o antigo nó raiz à direita de um novo nó raiz aumentaremos o dobro do limite inferior.
A inserção dinâmica pode ser definida de duas formas: dinâmica em ambos os lados ou dinâmica em apenas um dos lados e o outro fixo. Primeiro falaremos da dinâmica em apenas um dos lados por ser mais simples.

DINÂMICA EM UMA DIREÇÃO
Como agora a Árvore Oculta pode crescer dependendo da necessidade, podemos fixar nosso limite inferior como sendos 0, por exemplo, e nosso limite superior será dinâmico iniciando a partir do 0, e iremos aumentando ele em potências de 2 conforme for necessário. Dessa forma, se tivermos uma tendência de receber valores baixos incialmente e gradativamente irem aumentando, a árvore irá crescer balanceadamente desde sua concepção.
Na primeira inserção que fizermos (desde que seja uma chave maior que 0, pois definimos nosso limite inferior como 0 neste exemplo), encontraremos a menor potência de 2 maior que a chave a ser inserida e atribuímos esse valor ao nosso limite superior dinâmico. A partir daí temos nosso limite superior definido, só precisamos agora encontrar uma forma de fazê-lo crescer conforme formos precisando sem perder as  propriedades da árvore.
Antes, devemos notar que o intervalo atribuído a um nó específico não pode ser alterado, caso isso aconteça, irá quebrar as propriedades da árvore e precisaremos realocar os elementos já inseridos como forma de manter as propriedades, fazendo novas inserções para os elementos já inseridos e isso será muito custoso, logo não podemos saltar intervalos. Agora pense como resolveríamos o problema de cresimento dinâmico, se nosso limite superior crescer em potências de 2, e tivermos que inserir uma chave que seja maior que a próxima potência de 2.
Existem 3 formas de resolver este problema aqui chamadas: Dinamic Memory, Dinamic Jump e Dinamic Step.
  

DINAMIC MEMORY
Se tivermos um limite superior igual a 2 e necessitarmos incluir uma chave de valor 9, devemos alocar um novo nó cabeça que possuirá intervalo de 0 a 4, como o 9 não se encaixa nesse intervalo, atribuímos -1 (indicador que o nó não possui chave válida) a chave do nó recém-criado, alocamos outro nó cabeça que possuirá intervalo de 0 a 8 que também receberá -1, e alocamos outro nó cabeça de intervalo 0 a 16 onde inseriremos a chave 9. Este procedimento embora gaste mais memória do que o necessário é levemente mais rápido, simples e fácil de implementar do que os próximos dois métodos.
Quando formos incluir um novo elemento e encontrarmos um nó com chave igual a -1, nossa primeira opção é inserir o elemento neste nó, porém antes devemos verificar se essa chave é maior ou igual a MÉDIA, se sim, então podemos inserir ali mesmo, caso contrário continuamos descendo a árvore pela esquerda, para que não adicionemos um elemento no intervalo errado (isso para o modelo Árvore Binária de Pesquisa Oculta).
   

DINAMIC JUMP
Uma forma de contornarmos o problema da alocação em excesso é adequar o intervalo a necessidade do nó. Logo se tivermos um limite superior igual a 2 e precisarmos inserir uma chave de valor 5, alocamos um novo nó pai, atribuímos 5 a ele e definimos que o intervalo daquele nó vai de 0 a 8, pulando a alocação do nó de intervalo 0 a 4.
O problema agora é sabermos quando devemos criar o nó do meio que ficou faltando. A resposta é dada pelo teto do log da chave do filho da esquerda elevado a 2, ou em outras palavras, a próxima potência de 2 do filho da esquerda. Se a próxima potência de 2 do filho da esquerda for menor ou igual a chave que queremos inserir, então devemos criar um novo nó no meio e adicionar a nova chave. A explicação para isso é que a próxima potência de 2 do filho da esquerda retorna o limite superior do nó filho, logo se a chave que queremos inserir for maior ou igual (igual porque os limites não são inseridos nos nós filhos, logo o limite superior só pode existir no seu pai) a esse limite, então existe um nó faltando no meio.
Perceba que desta forma os elementos mais a esquerda sempre terão chaves maiores ou iguais a sua MÉDIA. Outro detalhe é que este salto de intervalo só acontecerá com os filhos mais a esquerda (seguindo o método de inserção dinâmica em apenas um dos limites, no caso o limite superior) quando uma nova cabeça for inserida, portanto se entrarmos uma única vez à direita de um nó saberemos que não é possível haver um salto de intervalo nos próximos nós.
  

DINAMIC STEP
O salto em degrau ou passo a passo, é parecido com o salto de intervalo, a diferença é que nesse caso não pularemos os intervalos, mas sim os valores, sendo necessária a realocação de algumas chaves. Nesse modelo, uma chave muito alta sendo inserida acima de uma chave baixa faria com que o limite superior apenas dobrasse, nesse caso teríamos um nó com uma chave mais alta do que o limite permitido daquele nó, porém vale lembrar que é uma situação temporária, mas caso queira-se saber o limite superior da árvore, este deve ser dado pelo limite da chave do nó cabeça. Dessa forma nunca iremos alocar um novo vértice no meio da árvore, ou alocamos um novo cabeça ou alocamos uma nova folha.
 
Esse modelo pode deixar as chaves fora de seus respectivos intervalos, porém a Árvore continuara de Pesquisa em todos os momentos. Como as chaves podem ficar fora de seus intervalos, não é possível aplicar esse modelo a Árvore Binária Oculta pois esta depende que os elementos estejam corretos em seus intervalos, apenas é possível para a Árvore Binária de Pesquisa Oculta.
Sempre que formos inserir uma chave, devemos verificar se ela é maior ou igual ao BOUND (limite superior do nó cabeça) ou se a chave do nó cabeça é maior ou igual ao BOUND, em qualquer situação é alocado uma nova cabeça que irá suprir esse desnível, logo o maior elemento entre a nova chave e a chave do nó cabeça será o novo nó cabeça, BOUND dobra, e caso seja a chave do antigo nó cabeça que tenha subido, precisamos continuar propagando a nova chave para baixo até encontrarmos a posição dela, que é logo abaixo do menor elemento maior que ela. Para esta situação, note que não podemos criar o novo nó cabeça antes de encontrarmos a posição da nova chave, pois pode ser que ela já esteja inserida nos nós abaixo. Logo seja verificado que a chave não está inserida, cria-se a nova cabeça com a chave do antigo pai e propaga a nova chave até sua devida posição.
    
Não sendo necessária a criação de uma nova cabeça, buscaremos inserir a nova chave da mesma forma como fazíamos antes, olhando para o meio do intervalo. Porém agora, poderemos ter chaves mais à esquerda que não estarão nos seus devidos lugares, sendo necessário inseri-las novamente para fazer elas subirem na árvore (estamos trabalhando sem recursividade). Para isso, sempre que fizermos a troca de valores pela propagação e em seguida formos para a direita, devemos verificar se a chave é maior ou igual ao limite daquele vértice, se for iremos chamar a função novamente passando essa chave como entrada, senão, continuamos normalmente.
  
Outra situação que ocorre também é quando fizemos essa troca pela propagação e vamos para a direita, antes devemos verificar se mais a baixo na esquerda já não existe aquela chave (se a estrutura não permitir chaves ambíguas), fazemos a troca e depois empurramos a chave do nó pai para baixo até sua posição, mesma situação que ocorreu na inserção de um novo nó cabeça e continuamos o processo, se existir, nada é feito.
  

LIMITE INFERIOR DINÂMICO
	Até agora trabalhamos apenas com o crescimento dinâmico para cima, mas e se quisermos um crescimento dinâmico para baixo? Se formos continuar a inserir os elementos na mesma estrutura, a medida que inserimos um elemento novo que muda o limite inferior, teremos que mudar também o MÉDIA de cada nó a esquerda do nó cabeça e isso causaria uma realocação de vários nós.
	Uma forma de evitar a realocação é criar uma segunda árvore com limite superior igual a 0 e o limite inferior dinâmico, como o limite superior é fixo podemos crescer indefinidamente para baixo da mesma forma como fazíamos para cima. E para ficar uma única estrutura basta adicionarmos um condicional nas funções já criadas e guardarmos uma variável para a cabeça da árvore negativa, então se a entrada dada nas funções for negativa trabalhamos com a árvore dos negativos se a entrada for positiva trabalhamos com a árvore dos positivos. Esta solução criará duas árvores, uma para crescimento dinâmico inferior e outra para crescimento dinâmico superior, separadamente.

DINÂMICA EM AMBAS DIREÇÕES SIMULTANEAMENTE
O método dinâmico em ambas as direções é um pouco mais complexo e deixará a Árvore uma altura maior, porém será uma única estrutura. Como os limites podem crescer uma hora pra um lado outra hora para outro, ocorrerá uma descontinuidade das potências de 2 vista de um único lado, podendo o limite superior, por exemplo, estourar a capacidade do tipo de dado e ter de haver um tratamento especial para isso. Por haver esse excesso de um lado e de outro é que a estrutura ganhará uma altura a mais na árvore.
Quando precisarmos dobrar o valor do limite e não possuímos memória de dado para isso devemos fazer um tratamento como se o limite realmente tivesse dobrado para não quebrar os limites dos nós filhos já inseridos. O tratamento over flow deve ser tratado na criação de um nó cabeça e depois na atualização dos limites quando descendo a árvore. Se verificado que a próxima atualização da MÉDIA resultará em over flow, então criaremos um parentese onde a nova MÉDIA será dada pelo limite em um dos lados e pelo valor máximo do tipo de dado do outro, com isso mantemos as propriedades da ávore.

DINAMIC MEMORY SIMULTÂNEO
Este modelo continua a mesma coisa que antes, com algumas pequenas adaptações na inserção para o tratamento do elemento não válido. Além disso é acrescentado também o tratamento de over flow.

DINAMIC JUMP SIMULTÂNEO
Este modelo altera sua forma de verificar o salto. Aqui não conseguimos descobrir qual o limite superior do filho como fazíamos antes pois a árvore cresce em ambas direções. É necessário então uma variável auxiliar que marque quais filhos estão com saltos de intervalo pendentes até seus pais. 
Podemos fazer isso de duas formas: com uma estrutura auxiliar do tipo unordered_map (considerando linguagem c++) para guardar os filhos que possuem salto de intervalo pendentes, afinal poucos filhos possuírão esta condição; ou uma variável na própria estrutura demarcando quantos saltos faltam até seu pai que gastará um pouco mais de memória.
Devido a grande quantidade de consultas a se fazer em cada peração e cuidados a se tomar, a forma criando uma variável extra na estrutura se tornou 2 vezes mais rápida que a outra forma, por isso a melhor opção neste modelo.

DINAMIC STEP SIMULTÂNEO
Este modelo de inserção que já era o mais complicado se tornou ainda mais complicado, porém o que gasta menos memória (considerando Dinamic Simultaneous) e tão rápido quanto os outros. 
Para este modelo precisaremos de dois ponteiros auxiliares que apontarão um para o maior elemento e outro para o menor elemento. Esses ponteiros serão utilizados na criação, ou não, de um novo nó cabeça. Porém aqui só criaremos uma nova cabeça quando a nova chave a ser alocado ultrapassar o limite do intervalo do nó raiz. Nessa ocasião olharemos para o ponteiro correspondente, se a chave a ser inserida for menor que o limite inferior do nó raiz verificamos o ponteiro para o menor elemento da árvore e vice-versa, comparamos qual o menor (considerando estouro do limite inferior) e criamos o novo nó cabeça com ele. Se for a chave que seria inserida, cria-se o pai apenas, caso contrário, criamos a cabeça com o valor do menor elemento e jogamos a nova chave para este elemento, em seguida fazemos a propagação dessa chave. 
A propagação neste modelo não deverá seguir em uma linha reta, como na inserção dinâmica em um dos lados apenas, deverá fazer este processo iterativamente quantas vezes necessário até que o próximo elemento da direita (considerando a criação da cabeça no limite inferior) possua uma chave maior que a chave do nó que estamos, ou seja, iremos sempre para a direita propagando a chave e quando não tiver elemento da direita seguimos pela esquerda até encontrar um nó com elemento da direita, então continuamos a propagação até o caso base. O mesmo acontece para o outro lado da árvore.
